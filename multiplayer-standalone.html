<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EWC Game - Multiplayer (Standalone)</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
            color: #eee;
            overflow: hidden;
            user-select: none;
        }
        
        #gameCanvas {
            display: block;
            cursor: crosshair;
            background: #1a1a2e;
        }
        
        .hidden {
            display: none !important;
        }
        
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%);
            z-index: 1000;
        }
        
        .start-content {
            text-align: center;
            max-width: 600px;
            padding: 20px;
        }
        
        .start-content h1 {
            font-size: 3.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #ff6b6b, #ff9f43);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }
        
        .start-content .subtitle {
            color: #4ecdc4;
            font-size: 1.25rem;
            margin-bottom: 2rem;
            font-weight: 500;
            opacity: 0.9;
        }
        
        .start-content input {
            padding: 16px 24px;
            font-size: 16px;
            margin: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(16px);
            color: white;
            text-align: center;
            min-width: 280px;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        
        .start-content input:focus {
            outline: none;
            border-color: #4ecdc4;
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 0 2px rgba(78, 205, 196, 0.2);
        }
        
        .start-content input::placeholder {
            color: rgba(255,255,255,0.7);
        }
        
        .start-content button {
            padding: 16px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #ff6b6b, #ff5252);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            margin: 16px;
            font-family: 'Inter', sans-serif;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.3);
        }
        
        .start-content button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(255, 107, 107, 0.4);
        }
        
        .start-content button:active {
            transform: translateY(-1px);
        }
        
        .game-info {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(26, 26, 46, 0.6));
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            margin-top: 24px;
            text-align: left;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .game-info h3 {
            background: linear-gradient(135deg, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
            font-weight: 600;
        }
        
        .game-info li {
            margin: 8px 0;
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: 400;
            line-height: 1.4;
        }
        
        /* HUD Styles */
        .hud-top {
            position: absolute;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 16px;
            align-items: center;
        }
        
        .score-display {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.15), rgba(255, 107, 107, 0.05));
            backdrop-filter: blur(12px);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
            font-size: 16px;
            font-weight: 600;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.1);
        }
        
        .game-stats {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.15), rgba(78, 205, 196, 0.05));
            backdrop-filter: blur(12px);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid rgba(78, 205, 196, 0.3);
            color: #4ecdc4;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(78, 205, 196, 0.1);
        }
        
        .fps-counter {
            background: linear-gradient(135deg, rgba(69, 183, 209, 0.15), rgba(69, 183, 209, 0.05));
            backdrop-filter: blur(12px);
            padding: 10px 16px;
            border-radius: 10px;
            border: 1px solid rgba(69, 183, 209, 0.3);
            color: #45b7d1;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(69, 183, 209, 0.1);
        }
        
        .leaderboard {
            position: absolute;
            top: 16px;
            right: 16px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.9));
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            min-width: 240px;
            max-width: 320px;
            color: white;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .connection-status {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.2), rgba(78, 205, 196, 0.1));
            backdrop-filter: blur(16px);
            border: 1px solid rgba(78, 205, 196, 0.4);
            border-radius: 24px;
            padding: 10px 20px;
            color: #4ecdc4;
            font-size: 13px;
            font-weight: 600;
            box-shadow: 0 4px 20px rgba(78, 205, 196, 0.2);
        }
        
        .chat-container {
            position: absolute;
            bottom: 16px;
            left: 16px;
            width: 360px;
            pointer-events: auto;
        }
        
        .chat-messages {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(26, 26, 46, 0.95));
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            height: 160px;
            overflow-y: auto;
            margin-bottom: 8px;
            font-size: 13px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .controls-help {
            position: absolute;
            bottom: 16px;
            right: 16px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.9));
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            font-size: 13px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        /* Growth notification */
        .growth-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 215, 0, 0.9);
            color: #000;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            z-index: 1000;
            animation: pulse 2s ease-out;
            display: none;
            pointer-events: none;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        /* VIP effects */
        .vip-indicator {
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen" class="start-screen">
        <div class="start-content">
            <h1>EWC Game.io</h1>
            <p class="subtitle">üåê Multiplayer Experience (Standalone)</p>
            
            <div class="game-info">
                <h3>üéÆ Enhanced Features:</h3>
                <ul>
                    <li>‚ö° <strong>Limited Splits:</strong> SPACE key for splitting (max 16 cells)</li>
                    <li>üéØ <strong>Growth Milestones:</strong> Bonus mass every 100 points</li>
                    <li>ü§ñ <strong>Smart AI:</strong> Challenging network-style opponents</li>
                    <li>üí¨ <strong>Chat System:</strong> Press T to chat with AI players</li>
                    <li>üèÜ <strong>Competitive Play:</strong> Real-time leaderboard rankings</li>
                    <li>üåç <strong>Multiplayer Feel:</strong> Authentic online gaming experience</li>
                </ul>
            </div>
            
            <br>
            <input type="text" id="playerName" placeholder="Enter your name" maxlength="128">
            <br>
            <button onclick="startGame()">üöÄ START MULTIPLAYER</button>
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- Growth Notification -->
    <div id="growthNotification" class="growth-notification"></div>

    <!-- HUD -->
    <div class="hud-top">
        <div class="score-display" id="scoreDisplay">Score: 0</div>
        <div class="game-stats" id="gameStats">Cells: 1 | Mass: 400</div>
        <div class="fps-counter" id="fpsCounter">FPS: 60</div>
    </div>

    <!-- Connection Status -->
    <div class="connection-status connected">
        Connected to EWC Game Server
    </div>

    <!-- Leaderboard -->
    <div class="leaderboard">
        <h3>üèÜ Leaderboard</h3>
        <div id="leaderboardContent">
            <div class="leaderboard-item">Loading...</div>
        </div>
    </div>

    <!-- Chat -->
    <div class="chat-container">
        <div class="chat-messages" id="chatMessages">
            <div class="chat-message system">üåü Welcome to EWC Game Enhanced!</div>
            <div class="chat-message system">üéÆ All single-player features integrated into multiplayer!</div>
            <div class="chat-message player"><span class="player-name">ProGamer2024:</span> This new version is amazing!</div>
            <div class="chat-message player"><span class="player-name">SpeedRunner:</span> Love the 16-cell split limit feature</div>
        </div>
        <div class="chat-input-container" id="chatInputContainer">
            <input type="text" id="chatInput" placeholder="Type a message..." maxlength="100">
        </div>
    </div>

    <!-- Controls Help -->
    <div class="controls-help">
        <h4>üéÆ Controls</h4>
        <div class="control-item">
            <span class="control-key">MOUSE</span>
            <span class="control-desc">Move</span>
        </div>
        <div class="control-item">
            <span class="control-key">SPACE</span>
            <span class="control-desc">Split</span>
        </div>
        <div class="control-item">
            <span class="control-key">T</span>
            <span class="control-desc">Chat</span>
        </div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let chatOpen = false;
        
        // World size
        const WORLD_WIDTH = 5000;  // Larger world like multiplayer
        const WORLD_HEIGHT = 5000;
        
        // Player cells (multiple cells for advanced split mechanics)
        let playerCells = [];
        let playerName = '';
        let isVIP = false;
        let isFermi = false;
        
        let playerStats = {
            score: 0,
            lastGrowthMilestone: 0,
            lastSplitTime: 0,
            splitCooldown: 750, // 0.75 second cooldown for smoother splitting
            splitSpeedBoost: false, // Track if player has post-split speed boost
            splitSpeedBoostEnd: 0 // When the speed boost ends
        };
        
        // Camera
        let camera = {
            x: 0,
            y: 0,
            zoom: 1
        };
        
        // Mouse
        let mouse = { x: 0, y: 0 };
        
        // Food
        let food = [];
        let networkPlayers = [];
        
        // FPS tracking
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let currentFPS = 60;
        
        // Easter egg images
        let fermiImage = null;
        
        // Load Easter egg images
        function loadEasterEggImages() {
            fermiImage = new Image();
            fermiImage.onload = function() {
                console.log('üñºÔ∏è Fermi image loaded successfully!');
            };
            fermiImage.onerror = function() {
                console.log('‚ö†Ô∏è Could not load Fermi image');
            };
            fermiImage.src = 'fermi.jpg';
        }
        
        // Initialize images on page load
        loadEasterEggImages();
        
        // Resize canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Player Cell Class
        class PlayerCell {
            constructor(x, y, mass, color, splitTime = 0) {
                this.id = Math.random();
                this.x = x;
                this.y = y;
                this.mass = mass;
                this.size = Math.sqrt(mass);
                this.color = color;
                this.vx = 0;
                this.vy = 0;
                this.splitTime = splitTime;
                this.canMerge = splitTime === 0;
            }
            
            update(deltaTime) {
                const currentTime = Date.now();
                
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Apply friction based on split status and mass
                const timeSinceSplit = currentTime - this.splitTime;
                const recentlySplit = timeSinceSplit < 2000; // First 2 seconds after split
                // Larger mass = more friction (slower deceleration) - reduced penalty
                const baseMass = 400;
                const massRatio = this.mass / baseMass; // Direct relationship for friction
                const baseFriction = recentlySplit ? 0.985 : 0.97;
                const friction = Math.max(0.92, baseFriction - (massRatio - 1) * 0.01); // Gentler friction penalty
                
                this.vx *= friction;
                this.vy *= friction;
                
                // Update size based on mass
                this.size = Math.sqrt(this.mass);
                
                // Update merge availability (cells can merge after 10 seconds)
                if (currentTime - this.splitTime > 10000) {
                    this.canMerge = true;
                }
                
                // Mass loss over time (very slow)
                if (this.mass > 64) {
                    this.mass *= 0.9999;
                }
                
                // World boundary constraints
                this.x = Math.max(this.size, Math.min(WORLD_WIDTH - this.size, this.x));
                this.y = Math.max(this.size, Math.min(WORLD_HEIGHT - this.size, this.y));
            }
        }
        
        // Network Player Class (AI simulation)
        class NetworkPlayer {
            constructor(name, x, y, mass) {
                this.id = Math.random();
                this.name = name;
                this.x = x;
                this.y = y;
                this.mass = mass;
                this.size = Math.sqrt(mass);
                this.color = getRandomColor();
                this.vx = 0;
                this.vy = 0;
                this.targetX = Math.random() * WORLD_WIDTH;
                this.targetY = Math.random() * WORLD_HEIGHT;
                this.changeTargetTimer = 0;
                this.score = Math.floor(mass / 4);
                this.lastChatTime = 0;
                // AI players are completely banned from VIP status
                this.isVIP = false; // No AI can ever be VIP
            }
            
            update(deltaTime) {
                // Change target occasionally
                this.changeTargetTimer++;
                if (this.changeTargetTimer > 300 + Math.random() * 600) {
                    this.targetX = Math.random() * WORLD_WIDTH;
                    this.targetY = Math.random() * WORLD_HEIGHT;
                    this.changeTargetTimer = 0;
                }
                
                // Move towards target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    // Speed inversely proportional to mass: larger AI = slower (reduced penalty)
                    const baseMass = 400; // Starting mass
                    const massRatio = Math.sqrt(baseMass / this.mass); // Square root for gentler reduction
                    const baseSpeed = Math.max(1.5, 15 * massRatio); // Less severe speed decrease
                    const speed = Math.max(1.2, baseSpeed); // Higher minimum speed cap
                    this.vx += (dx / distance) * speed * 0.4;
                    this.vy += (dx / distance) * speed * 0.4;
                }
                
                // Mass-based friction for AI players: larger = more friction - reduced penalty
                const baseMass = 400;
                const massRatio = this.mass / baseMass; // Direct relationship for friction
                const baseFriction = 0.94;
                const friction = Math.max(0.90, baseFriction - (massRatio - 1) * 0.008); // Gentler friction penalty
                this.vx *= friction;
                this.vy *= friction;
                
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Update size and score
                this.size = Math.sqrt(this.mass);
                this.score = Math.floor(this.mass / 4);
                
                // Mass loss over time
                if (this.mass > 64) {
                    this.mass *= 0.9999;
                }
                
                // Eat food
                food.forEach((f, index) => {
                    const dist = Math.sqrt((this.x - f.x) ** 2 + (this.y - f.y) ** 2);
                    if (dist < this.size / 2 + f.size) {
                        this.mass += f.mass;
                        food.splice(index, 1);
                    }
                });
                
                // Random chat
                const currentTime = Date.now();
                if (currentTime - this.lastChatTime > 30000 + Math.random() * 60000) {
                    this.lastChatTime = currentTime;
                    
                    const messages = [
                        "Nice moves!",
                        "This new version is sick!",
                        "Love the split mechanics",
                        "GG everyone",
                        "The Easter eggs are cool",
                        "VIP mode is OP lol",
                        "These visual effects üî•",
                        "Anyone else enjoying the updates?",
                        "16-cell limit is perfect!",
                        "The growth milestones are awesome"
                    ];
                    
                    const message = messages[Math.floor(Math.random() * messages.length)];
                    addChatMessage(this.name, message);
                }
                
                // World boundary constraints
                this.x = Math.max(this.size, Math.min(WORLD_WIDTH - this.size, this.x));
                this.y = Math.max(this.size, Math.min(WORLD_HEIGHT - this.size, this.y));
            }
        }
        
        // Network player names (more realistic)
        const networkPlayerNames = [
            'ProGamer2024', 'SpeedRunner', 'CellMaster', 'SplitKing', 'Ninja_Player',
            'GameChanger', 'EliteCell', 'QuickSplit', 'MegaGrower', 'ChatGPT_Fan',
            'CodeWarrior', 'PixelHunter', 'FastFingers', 'CyberCell', 'NetNinja',
            'SkillShot', 'RapidFire', 'CellStorm', 'PowerPlayer', 'TechGuru',
            // Easter egg names reserved for players only
        ];
        
        // Create network players
        function createNetworkPlayers() {
            // Clear existing network players to ensure no VIP AI remains
            networkPlayers = [];
            
            for (let i = 0; i < 15; i++) { // 15 simulated network players
                const name = networkPlayerNames[i] || `Player${i}`;
                const x = Math.random() * WORLD_WIDTH;
                const y = Math.random() * WORLD_HEIGHT;
                const mass = 300 + Math.random() * 600;
                
                networkPlayers.push(new NetworkPlayer(name, x, y, mass));
            }
            
            // Double-check: ensure NO AI player has VIP status
            networkPlayers.forEach(player => {
                player.isVIP = false;
            });
        }
        
        // Easter egg detection (case sensitive)
        function checkEasterEgg(name) {
            isVIP = name === 'fwang' || name === 'Tchiang';
            isFermi = name === 'fwang';
            return isVIP;
        }
        
        // Initialize player
        function initializePlayer(name) {
            playerName = name;
            checkEasterEgg(name);
            
            const initialMass = isVIP ? 1000 : 400;
            const color = isVIP ? '#FFD700' : getRandomColor();
            
            playerCells = [new PlayerCell(
                WORLD_WIDTH / 2, 
                WORLD_HEIGHT / 2, 
                initialMass, 
                color
            )];
            
            playerStats.score = Math.floor(initialMass / 4);
            playerStats.splitSpeedBoost = false; // Reset speed boost on initialization
            playerStats.splitSpeedBoostEnd = 0;
            if (isVIP) {
                playerStats.lastGrowthMilestone = Math.floor(playerStats.score / 100);
            }
        }
        
        // Update camera
        function updateCamera() {
            if (playerCells.length === 0) return;
            
            // Find center of all player cells
            let centerX = 0, centerY = 0, totalMass = 0, maxSize = 0;
            
            playerCells.forEach(cell => {
                centerX += cell.x * cell.mass;
                centerY += cell.y * cell.mass;
                totalMass += cell.mass;
                maxSize = Math.max(maxSize, cell.size);
            });
            
            if (totalMass > 0) {
                centerX /= totalMass;
                centerY /= totalMass;
                
                // Smooth camera movement
                const lerpFactor = 0.05;
                camera.x += (centerX - camera.x) * lerpFactor;
                camera.y += (centerY - camera.y) * lerpFactor;
                
                // Dynamic zoom based on total mass and spread
                const targetZoom = Math.max(0.3, Math.min(1, 600 / Math.sqrt(totalMass)));
                camera.zoom += (targetZoom - camera.zoom) * 0.02;
            }
        }
        
        // Update player
        function updatePlayer(deltaTime) {
            const currentTime = Date.now();
            
            // Calculate total mass and score
            const totalMass = playerCells.reduce((sum, cell) => sum + cell.mass, 0);
            playerStats.score = Math.floor(totalMass / 4);
            
            // Update each player cell
            playerCells.forEach(cell => {
                const dx = mouse.x / camera.zoom + camera.x - cell.x;
                const dy = mouse.y / camera.zoom + camera.y - cell.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    // Check if speed boost from splitting is active
                    const currentTime = Date.now();
                    if (playerStats.splitSpeedBoost && currentTime > playerStats.splitSpeedBoostEnd) {
                        playerStats.splitSpeedBoost = false; // Remove boost after 1.5 seconds
                    }
                    
                    // Speed inversely proportional to mass: larger = slower (reduced penalty)
                    const baseMass = 400; // Starting mass
                    const massRatio = Math.sqrt(baseMass / cell.mass); // Square root for gentler reduction
                    const baseSpeed = Math.max(3, 25 * massRatio); // Less severe speed decrease
                    let speed = Math.max(2, baseSpeed); // Higher minimum speed cap
                    
                    // Apply post-split speed boost (50% speed increase for 1.5 seconds)
                    if (playerStats.splitSpeedBoost) {
                        speed *= 1.5; // 50% speed increase
                    }
                    
                    cell.vx += (dx / distance) * speed * 0.5;
                    cell.vy += (dy / distance) * speed * 0.5;
                }
                
                cell.update(deltaTime);
            });
            
            // Handle cell interactions (collision prevention and merging)
            for (let i = playerCells.length - 1; i >= 0; i--) {
                for (let j = i - 1; j >= 0; j--) {
                    const cell1 = playerCells[i];
                    const cell2 = playerCells[j];
                    const dx = cell1.x - cell2.x;
                    const dy = cell1.y - cell2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = (cell1.size + cell2.size) / 2;
                    
                    if (distance < minDistance) {
                        // Prevent overlap by pushing apart
                        const pushForce = (minDistance - distance) * 2.5;
                        const pushX = (dx / distance) * pushForce;
                        const pushY = (dy / distance) * pushForce;
                        
                        cell1.x += pushX * 2.5;
                        cell1.y += pushY * 2.5;
                        cell2.x -= pushX * 2.5;
                        cell2.y -= pushY * 2.5;
                        
                        // Check for merging (both cells must be ready)
                        if (cell1.canMerge && cell2.canMerge) {
                            const massThreshold = Math.abs(cell1.mass - cell2.mass) < Math.min(cell1.mass, cell2.mass) * 0.1;
                            const easyMergeDistance = (cell1.size + cell2.size) / 3;
                            
                            if (distance < easyMergeDistance && massThreshold) {
                                // Merge cells
                                cell2.mass += cell1.mass;
                                cell2.size = Math.sqrt(cell2.mass);
                                cell2.x = (cell1.x * cell1.mass + cell2.x * cell2.mass) / (cell1.mass + cell2.mass);
                                cell2.y = (cell1.y * cell1.mass + cell2.y * cell2.mass) / (cell1.mass + cell2.mass);
                                cell2.splitTime = 0;
                                cell2.canMerge = true;
                                playerCells.splice(i, 1);
                                break;
                            } else if (distance < easyMergeDistance * 1.5) {
                                // Magnetic attraction for easy merging
                                const attractionForce = Math.max(2.5, (easyMergeDistance * 1.5 - distance) / 4);
                                const attractX = (dx / distance) * attractionForce;
                                const attractY = (dy / distance) * attractionForce;
                                
                                cell1.vx -= attractX * 1.5;
                                cell1.vy -= attractY * 1.5;
                                cell2.vx += attractX * 1.5;
                                cell2.vy += attractY * 1.5;
                            }
                        }
                    }
                }
            }
            
            // Check growth milestones
            const currentMilestone = Math.floor(playerStats.score / 100);
            if (currentMilestone > playerStats.lastGrowthMilestone) {
                playerStats.lastGrowthMilestone = currentMilestone;
                
                // Add bonus mass to largest cell
                if (playerCells.length > 0) {
                    const largestCell = playerCells.reduce((max, cell) => cell.mass > max.mass ? cell : max);
                    largestCell.mass += 100;
                    
                    showGrowthNotification(`üéâ Milestone! +100 Mass Bonus!`);
                }
            }
        }
        
        // Show growth notification
        function showGrowthNotification(message) {
            const notification = document.getElementById('growthNotification');
            notification.textContent = message;
            notification.style.display = 'block';
            notification.style.animation = 'none';
            setTimeout(() => {
                notification.style.animation = 'pulse 2s ease-out';
            }, 10);
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }
        
        // Split function (limited to 16 cells maximum)
        function splitPlayer() {
            const currentTime = Date.now();
            
            if (currentTime - playerStats.lastSplitTime < playerStats.splitCooldown) {
                return;
            }
            
            // Check 16-cell limit before splitting
            if (playerCells.length >= 16) {
                showGrowthNotification("‚ö†Ô∏è Maximum 16 cells reached!");
                return;
            }
            
            const cellsToSplit = playerCells.filter(cell => cell.mass > 64);
            if (cellsToSplit.length === 0) return;
            
            // Limit splits to not exceed 16 cells total
            const maxSplits = Math.min(cellsToSplit.length, 16 - playerCells.length);
            const cellsToActuallySplit = cellsToSplit.slice(0, maxSplits);
            
            cellsToActuallySplit.forEach(cell => {
                const newMass = cell.mass / 2;
                const newSize = Math.sqrt(newMass);
                const angle = Math.atan2(mouse.y / camera.zoom + camera.y - cell.y, 
                                       mouse.x / camera.zoom + camera.x - cell.x);
                
                const separationDistance = newSize * 2.0;
                
                // Create new cell
                const newCell = new PlayerCell(
                    cell.x + Math.cos(angle) * separationDistance,
                    cell.y + Math.sin(angle) * separationDistance,
                    newMass,
                    cell.color,
                    currentTime
                );
                // Enhanced split velocity for smoother animation
                const baseMass = 400;
                const massRatio = baseMass / newMass;
                
                // Smoother split speeds with easing
                const baseSplitSpeed = Math.max(60, 120 * Math.sqrt(massRatio));
                const splitSpeed = baseSplitSpeed + (Math.random() - 0.5) * 20; // Add slight randomness
                
                newCell.vx = Math.cos(angle) * splitSpeed;
                newCell.vy = Math.sin(angle) * splitSpeed;
                
                // Update original cell with smoother positioning
                const smoothSeparation = separationDistance * 0.8; // Slightly closer initially
                cell.x = cell.x - Math.cos(angle) * smoothSeparation;
                cell.y = cell.y - Math.sin(angle) * smoothSeparation;
                cell.mass = newMass;
                cell.size = newSize;
                
                // Original cell gets opposite velocity with smooth easing
                const originalSpeed = baseSplitSpeed * 0.75 + (Math.random() - 0.5) * 15;
                cell.vx = -Math.cos(angle) * originalSpeed;
                cell.vy = -Math.sin(angle) * originalSpeed;
                cell.splitTime = currentTime;
                cell.canMerge = false;
                
                playerCells.push(newCell);
            });
            
            playerStats.lastSplitTime = currentTime;
            
            // Apply post-split speed boost (50% faster for 1.5 seconds)
            playerStats.splitSpeedBoost = true;
            playerStats.splitSpeedBoostEnd = currentTime + 1500; // 1.5 seconds
            
            // Simulate network notification
            if (Math.random() < 0.3) {
                const messages = ["Nice split!", "Smooth move", "Split master!", "Clean split"];
                const randomPlayer = networkPlayers[Math.floor(Math.random() * networkPlayers.length)];
                setTimeout(() => {
                    addChatMessage(randomPlayer.name, messages[Math.floor(Math.random() * messages.length)]);
                }, 500 + Math.random() * 2000);
            }
        }
        
        // Create food
        function createFood() {
            food = [];
            for (let i = 0; i < 800; i++) {
                food.push({
                    x: Math.random() * WORLD_WIDTH,
                    y: Math.random() * WORLD_HEIGHT,
                    size: 3 + Math.random() * 4,
                    color: getRandomColor(),
                    mass: 8
                });
            }
        }
        
        // Get random color
        function getRandomColor() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', '#fd79a8', '#00b894', '#fdcb6e'];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // Update collisions
        function updateCollisions() {
            // Player eating food
            playerCells.forEach((cell, cellIndex) => {
                food.forEach((f, foodIndex) => {
                    const distance = Math.sqrt((cell.x - f.x) ** 2 + (cell.y - f.y) ** 2);
                    if (distance < cell.size / 2 + f.size) {
                        cell.mass += f.mass;
                        food.splice(foodIndex, 1);
                        
                        // Replenish food
                        food.push({
                            x: Math.random() * WORLD_WIDTH,
                            y: Math.random() * WORLD_HEIGHT,
                            size: 3 + Math.random() * 4,
                            color: getRandomColor(),
                            mass: 8
                        });
                    }
                });
                
                // Player eating network players
                networkPlayers.forEach((netPlayer, netIndex) => {
                    const dx = cell.x - netPlayer.x;
                    const dy = cell.y - netPlayer.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < (cell.size + netPlayer.size) / 2) {
                        if (cell.mass > netPlayer.mass * 1.2) {
                            cell.mass += netPlayer.mass * 0.8;
                            respawnNetworkPlayer(netPlayer);
                            
                            // Simulate reactions
                            setTimeout(() => {
                                addChatMessage(netPlayer.name, "GG! Nice eat");
                            }, 1000);
                        } else if (netPlayer.mass > cell.mass * 1.2) {
                            // Network player eats player cell
                            netPlayer.mass += cell.mass * 0.8;
                            netPlayer.size = Math.sqrt(netPlayer.mass);
                            netPlayer.score = Math.floor(netPlayer.mass / 4);
                            playerCells.splice(cellIndex, 1);
                            
                            if (playerCells.length === 0) {
                                gameOver();
                            }
                        }
                    }
                });
            });
        }
        
        function respawnNetworkPlayer(player) {
            player.x = Math.random() * WORLD_WIDTH;
            player.y = Math.random() * WORLD_HEIGHT;
            player.mass = 300 + Math.random() * 400;
            player.size = Math.sqrt(player.mass);
            player.score = Math.floor(player.mass / 4);
            player.color = getRandomColor();
            // Ensure AI players never have VIP status, even when respawning
            player.isVIP = false;
        }
        
        function gameOver() {
            alert('Game Over! Final Score: ' + playerStats.score);
            location.reload();
        }
        
        // Render functions
        function renderBackground() {
            // Grid background
            const gridSize = 50;
            const startX = Math.floor((camera.x - canvas.width / (2 * camera.zoom)) / gridSize) * gridSize;
            const startY = Math.floor((camera.y - canvas.height / (2 * camera.zoom)) / gridSize) * gridSize;
            const endX = startX + canvas.width / camera.zoom + gridSize;
            const endY = startY + canvas.height / camera.zoom + gridSize;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            for (let x = startX; x <= endX; x += gridSize) {
                const screenX = (x - camera.x) * camera.zoom;
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y <= endY; y += gridSize) {
                const screenY = (y - camera.y) * camera.zoom;
                ctx.beginPath();
                ctx.moveTo(0, screenY);
                ctx.lineTo(canvas.width, screenY);
                ctx.stroke();
            }
        }
        
        function renderFood() {
            food.forEach(f => {
                const x = (f.x - camera.x) * camera.zoom;
                const y = (f.y - camera.y) * camera.zoom;
                
                if (x > -20 && x < canvas.width + 20 && y > -20 && y < canvas.height + 20) {
                    ctx.fillStyle = f.color;
                    ctx.beginPath();
                    ctx.arc(x, y, f.size * camera.zoom, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
        
        function renderPlayerCell(cell) {
            const x = (cell.x - camera.x) * camera.zoom;
            const y = (cell.y - camera.y) * camera.zoom;
            const radius = cell.size * camera.zoom / 2;
            const currentTime = Date.now();
            const timeSinceSplit = currentTime - cell.splitTime;
            const justSplit = timeSinceSplit < 1000;
            
            // Body rendering
            if (isFermi && fermiImage && fermiImage.complete) {
                // Draw Fermi themed cell with image
                ctx.save();
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.clip();
                
                const imageSize = radius * 2;
                ctx.drawImage(fermiImage, x - radius, y - radius, imageSize, imageSize);
                ctx.restore();
                
                // Add golden overlay
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Standard cell rendering
                ctx.fillStyle = cell.color;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Border (gold for VIP)
            ctx.strokeStyle = isVIP ? '#FFD700' : '#fff';
            ctx.lineWidth = isVIP ? 4 : 3;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // VIP glow effect
            if (isVIP) {
                const auraIntensity = 0.6 + 0.4 * Math.sin(currentTime * 0.005);
                ctx.strokeStyle = `rgba(255, 215, 0, ${auraIntensity * 0.8})`;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(x, y, radius + 8, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Enhanced split effects with smoother animation
            if (justSplit) {
                const progress = timeSinceSplit / 1000; // 0 to 1 over 1 second
                const glowIntensity = 1 - progress;
                const pulseEffect = Math.sin(progress * Math.PI * 6) * 0.3 + 0.7; // Pulsing effect
                
                // Primary split glow
                ctx.strokeStyle = `rgba(0, 255, 255, ${glowIntensity * pulseEffect * 0.8})`;
                ctx.lineWidth = 4 + glowIntensity * 3;
                ctx.beginPath();
                ctx.arc(x, y, radius + 2 + glowIntensity * 8, 0, Math.PI * 2);
                ctx.stroke();
                
                // Secondary split ring effect
                if (progress < 0.5) {
                    const ringIntensity = (0.5 - progress) * 2;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${ringIntensity * 0.4})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius + 10 + (1 - ringIntensity) * 15, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Merge readiness indicator
            if (cell.canMerge) {
                const pulseIntensity = 0.5 + 0.3 * Math.sin(currentTime * 0.01);
                ctx.strokeStyle = `rgba(0, 255, 0, ${pulseIntensity * 0.6})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius + 4, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, radius - 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Always show player name on cells
            const fontSize = Math.max(10, radius * 0.25);
            ctx.fillStyle = isVIP ? '#FFD700' : '#fff';
            ctx.font = `${fontSize}px Inter, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const displayName = isVIP ? `üëë ${playerName} üëë` : playerName;
            
            // Name background for better readability
            const textWidth = ctx.measureText(displayName).width;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(x - textWidth/2 - 4, y + radius + 12, textWidth + 8, fontSize + 6);
            
            // Name text
            ctx.fillStyle = isVIP ? '#FFD700' : '#fff';
            ctx.fillText(displayName, x, y + radius + 20);
        }
        
        function renderNetworkPlayer(player) {
            const x = (player.x - camera.x) * camera.zoom;
            const y = (player.y - camera.y) * camera.zoom;
            const radius = player.size * camera.zoom / 2;
            
            // Body
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Border
            ctx.strokeStyle = player.isVIP ? '#FFD700' : '#333';
            ctx.lineWidth = player.isVIP ? 3 : 2;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // VIP glow for network VIP players
            if (player.isVIP) {
                const currentTime = Date.now();
                const auraIntensity = 0.4 + 0.2 * Math.sin(currentTime * 0.003);
                ctx.strokeStyle = `rgba(255, 215, 0, ${auraIntensity})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(x, y, radius + 6, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Name (always show)
            const fontSize = Math.max(10, radius * 0.25);
            ctx.fillStyle = player.isVIP ? '#FFD700' : '#fff';
            ctx.font = `${fontSize}px Inter, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const displayName = player.isVIP ? `üëë ${player.name} üëë` : player.name;
            
            // Name background for better readability
            const textWidth = ctx.measureText(displayName).width;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(x - textWidth/2 - 4, y + radius + 12, textWidth + 8, fontSize + 6);
            
            // Name text
            ctx.fillStyle = player.isVIP ? '#FFD700' : '#fff';
            ctx.fillText(displayName, x, y + radius + 20);
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            renderBackground();
            renderFood();
            
            // Sort entities by size for proper layering
            const allEntities = [...playerCells, ...networkPlayers].sort((a, b) => a.size - b.size);
            
            allEntities.forEach(entity => {
                if (playerCells.includes(entity)) {
                    renderPlayerCell(entity);
                } else {
                    renderNetworkPlayer(entity);
                }
            });
            
            ctx.restore();
            
            // Update UI
            updateUI();
        }
        
        // Update UI
        function updateUI() {
            // Score
            document.getElementById('scoreDisplay').textContent = `Score: ${playerStats.score}`;
            
            // Game stats
            const totalMass = playerCells.reduce((sum, cell) => sum + cell.mass, 0);
            document.getElementById('gameStats').textContent = `Cells: ${playerCells.length} | Mass: ${Math.floor(totalMass)}`;
            
            // FPS
            document.getElementById('fpsCounter').textContent = `FPS: ${currentFPS}`;
        }
        
        // Update leaderboard
        function updateLeaderboard() {
            const leaderboard = [
                { name: playerName, score: playerStats.score, isPlayer: true },
                ...networkPlayers.map(p => ({ name: p.name, score: p.score, isVIP: p.isVIP }))
            ].sort((a, b) => b.score - a.score).slice(0, 8);
            
            const leaderboardHtml = leaderboard.map((p, i) => {
                const nameClass = p.isPlayer ? 'style="color: #4ecdc4; font-weight: bold;"' : '';
                const vipIndicator = p.isVIP ? 'üëë ' : '';
                const displayName = `${vipIndicator}${p.name}`;
                return `<div class="leaderboard-item">
                    <span class="rank">${i + 1}.</span>
                    <span class="name" ${nameClass}>${displayName}</span>
                    <span class="score">${p.score}</span>
                </div>`;
            }).join('');
            
            document.getElementById('leaderboardContent').innerHTML = leaderboardHtml;
        }
        
        // Chat system
        function addChatMessage(sender, message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageElement = document.createElement('div');
            messageElement.classList.add('chat-message', sender === 'System' ? 'system' : 'player');
            
            if (sender === 'System') {
                messageElement.textContent = message;
            } else {
                messageElement.innerHTML = `<span class="player-name">${sender}:</span> ${message}`;
            }
            
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Limit chat history
            while (chatMessages.children.length > 50) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }
        
        function toggleChat() {
            const chatInput = document.getElementById('chatInput');
            const chatContainer = document.getElementById('chatInputContainer');
            
            chatOpen = !chatOpen;
            
            if (chatOpen) {
                chatContainer.style.display = 'block';
                chatInput.focus();
            } else {
                chatContainer.style.display = 'none';
                chatInput.value = '';
            }
        }
        
        // Mouse movement
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameRunning && !chatOpen) {
                e.preventDefault();
                splitPlayer();
            } else if (e.code === 'KeyT' && gameRunning) {
                e.preventDefault();
                toggleChat();
            } else if (e.code === 'KeyR') {
                location.reload();
            } else if (e.code === 'Enter' && chatOpen) {
                const input = document.getElementById('chatInput');
                if (input.value.trim()) {
                    addChatMessage(playerName, input.value.trim());
                    input.value = '';
                }
                toggleChat();
            } else if (e.code === 'Escape' && chatOpen) {
                toggleChat();
            }
        });
        
        // Start game function
        function startGame() {
            const nameInput = document.getElementById('playerName');
            const name = nameInput.value.trim() || 'Anonymous';
            
            initializePlayer(name);
            
            document.getElementById('startScreen').classList.add('hidden');
            gameRunning = true;
            
            createFood();
            createNetworkPlayers();
            
            // Show Easter egg message
            if (isVIP) {
                setTimeout(() => {
                    const easterEggMsg = isFermi ? 
                        "üéâ FWANG EASTER EGG ACTIVATED! üñºÔ∏è Special theme + VIP privileges!" :
                        "üéâ TCHIANG EASTER EGG ACTIVATED! üëë Special privileges unlocked!";
                    addChatMessage('System', easterEggMsg);
                }, 1000);
            }
            
            gameLoop();
        }
        
        // Game loop
        function gameLoop(currentTime = 0) {
            if (!gameRunning) return;
            
            const deltaTime = (currentTime - lastTime) / 16.67; // 60 FPS normalization
            lastTime = currentTime;
            
            // FPS calculation
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                currentFPS = Math.round(frameCount * 1000 / (currentTime - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }
            
            updatePlayer(deltaTime);
            updateCamera();
            updateCollisions();
            
            // Update network players
            networkPlayers.forEach(player => player.update(deltaTime));
            
            // Update leaderboard periodically
            if (Math.random() < 0.02) {
                updateLeaderboard();
            }
            
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // Simulate network activity every 30 seconds
        setInterval(() => {
            if (Math.random() < 0.05) {
                const messages = [
                    "Server maintenance in 30 minutes",
                    "Welcome new players!",
                    "Remember to use your splits wisely",
                    "Try the Easter eggs!"
                ];
                const message = messages[Math.floor(Math.random() * messages.length)];
                addChatMessage('Server', message);
            }
        }, 30000);
        
        // Random network events
        setInterval(() => {
            // Random network player changes
            if (Math.random() < 0.1) {
                const randomPlayer = networkPlayers[Math.floor(Math.random() * networkPlayers.length)];
                randomPlayer.targetX = Math.random() * WORLD_WIDTH;
                randomPlayer.targetY = Math.random() * WORLD_HEIGHT;
            }
        }, 15000 + Math.random() * 10000); // Every 15-25 seconds
        
        // Initialize
        console.log('üéÆ EWC Game Multiplayer Standalone loaded!');
        console.log('üåü All single-player features integrated');
        console.log('üéØ Try Easter egg names: fwang, Tchiang');
        
        // Continuously ensure AI players never have VIP status
        setInterval(() => {
            networkPlayers.forEach(player => {
                if (player.isVIP) {
                    player.isVIP = false; // Force remove any VIP status
                    player.color = getRandomColor(); // Reset color if it was gold
                }
            });
        }, 1000); // Check every second
        
        // Simulate network activity
        setInterval(() => {
            // Simulate players joining/leaving
            if (Math.random() < 0.1) {
                const actions = ['joined', 'left'];
                const action = actions[Math.floor(Math.random() * actions.length)];
                const names = ['QuickPlayer', 'CellHunter', 'SplitMaster', 'NewPlayer'];
                const name = names[Math.floor(Math.random() * names.length)];
                addChatMessage('System', `${name} ${action} the game`);
            }
        }, 30000); // Every 30 seconds
    </script>
</body>
</html>
